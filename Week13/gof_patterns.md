# Patterns

## Creational Patterns:

### Abstract Factory Pattern:
Provides a function that creates families of related or dependent values without specifying their concrete types.

### Builder Pattern:
Separates the construction of a complex structure from its representation, allowing the same construction process to create different representations.

<!-- This is in the reading. Don't do this Pattern. -->
### Factory Method Pattern:
Defines a function for creating a value but lets other functions alter the type of values that will be created.

### Prototype Pattern:
Creates new values by copying an existing value, known as the prototype.

<!-- This is in the reading. Don't do this Pattern. -->
### Singleton Pattern:
Ensures a function has only one instance and provides a global point of access to it.




## Structural Patterns:

<!-- This is in the reading. Don't do this Pattern. -->
### Adapter Pattern:
Allows a function's interface to be used as another interface.

### Bridge Pattern:
Separates a function's abstraction from its implementation so that the two can vary independently.

<!-- This is in the reading. Don't do this Pattern. -->
### Composite Pattern:
Composes functions into tree structures to represent part-whole hierarchies. 
It lets functions treat individual values and compositions of values uniformly.

<!-- This is in the reading. Don't do this Pattern. -->
### Decorator Pattern:
Attaches additional functionality to a function dynamically. 
Decorators provide a flexible alternative to higher-order functions for extending functionality.

<!-- This is in the reading. Don't do this Pattern. -->
### Facade Pattern:
Provides a simplified interface to a set of functions in a subsystem, making it easier to use.

### Flyweight Pattern:
Uses sharing to support a large number of fine-grained values efficiently.

### Proxy Pattern:
Provides a surrogate or placeholder for another function to control access to it.




## Behavioral Patterns:

### Chain of Responsibility Pattern:
Passes requests along a chain of functions. Upon receiving a request, each function decides either to process the request or to pass it along the chain.

### Command Pattern:
Encapsulates a request as a function, thereby allowing for parameterization of functions with different requests, queuing of requests, and logging of the requests.

### Interpreter Pattern:
Defines a grammar for the language and a function to interpret sentences in the language.

### Iterator Pattern:
Provides a way to access the elements of a collection sequentially without exposing its underlying representation.

### Mediator Pattern:
Defines a function that centralizes communication between functions in a system, making them independent of one another.

### Memento Pattern:
Captures and externalizes a function's internal state so that the function can be restored to this state later.

<!-- This is in the reading. Don't do this Pattern. -->
### Observer Pattern:
Defines a one-to-many dependency between functions so that when one function changes state, all its dependents are notified and updated automatically.

### State Pattern:
Allows a function to alter its behavior when its internal state changes. 
The function will appear to change its behavior.

<!-- This is in the reading. Don't do this Pattern. -->
### Strategy Pattern:
Defines a family of algorithms, encapsulates each one, and makes them interchangeable. 
Strategy lets the algorithm vary independently from functions that use it.

### Template Method Pattern:
Defines the structure of an algorithm in a higher-order function but lets other functions alter certain steps of the algorithm without changing its structure.

### Visitor Pattern:
Represents an operation to be performed on the elements of a data structure. 
Visitor lets you define a new operation without changing the functions of the elements on which it operates.
